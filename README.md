# WEB APPLICATION WITH REACT AND REDUX

Based on the web [tutorial series](https://www.youtube.com/playlist?list=PLuNEz8XtB51K-x3bwCC9uNM_cxXaiCcRY) by Rem Zolotykh.


## START WITH:
Lesson 4


#### To Run:
```
$ npm run server
```

#### To Stop (on Windows):
```
Ctrl-c
$ taskkill /F /IM node.exe
```

### HELPFUL RESOURCES:
* [webpack configuration guide](https://webpack.js.org/configuration/)
* don't forget that you can use the react extension in dev tools to examine the composition and state of your react components



## PROJECT NOTES:

#### APPLICATION OVERVIEW:
* our login application consists of the main app layout component, nav bar, greeting and signup form, the display of which is controlled by routing.



#### PACKAGE.JSON
* `scripts: nodemon` watches the server directory for changes and refreshes its execution of `babel-node`
    - `nodemon` is handling the filename `index.js`, not `babel-node`, hence the '--'
    - webpack will take care of the client directory

#### WEBPACK CONFIG
* webpack can take any file (`path: '/'`) because middleware serves from memory (rather than saving a file like 'bundle.js')
* `devtool: 'eval-source-map'` provides more information while debugging making it easier to track down errors
* webpack doesn't know anything about js (or other languages) so the `rules` array tells webpack how to handle certain kinds of files
    - `test` certain file extensions
    - `include` only from a certain directory
    - `loader` using the appropriate loader
* `entry` must be an array as it is used both to serve up the client directory but also it is used by the express middleware
* plugins:
    - `HotModuleReplacementPlugin`: most important
    - `NoEmitOnErrorsPlugin`: cleaner errors


#### BABELRC
* babel does the transpiling of ES6 code
* babel doesn't understand react by default, so add that in there too

#### INDEX.HTML
* the script src is 'bundle.js' but there's no such file in our project. that's because the file is dynamically generated by webpack and served up to the browser

#### INDEX.JS (SERVER)
* define the interface between our express server and our entry point ('index.html')
* configuring webpack
    - we use the webpack config file from our root dir by importing the file and creating `const compiler`
    - then we add configuration specifically for webpackMiddleware with our `app.use()` statements
    - 'noInfo' reduces noise from webpack
* hot middleware is needed for using express

#### INDEX.JS (CLIENT)
* here is where we render the components that will go into 'bundle.js'
* introducing routes:
    - rather than loading the `App` component, we will use `Router` to show different content based on different conditions (are we logged in or out?)
    - your router needs `browserHistory`
    - the routes themselves are saved in a separate file ('routes.js')


#### APP.JS
* _your top component must be a class component rather than a functional component_
    ```javascript
    // CLASS COMPONENT:
    class App extends React.Component {
        render() {
            return (
                <h1>Hello Mars!</h1>
            );    
        }
    }
    export default App;
    // VERSUS THE FUNCTIONAL:
    export default () => {
        return (
            <h1>Greetings, Venus!</h1>
        );
    }
    ```
* because our app uses several different components as 'top' components depending on routing, all of our router components need to be classes (App, Greetings, SignupPage)


#### ROUTES.JS
* your route requires two props:
    - the path
    - the component being rendered
* `IndexRoute` is like a default root route -- "when nothing else is specified, display this"



#### SIGNUPFORM
* our form will need state and needs to be a class component



Quick updates : - with React now you can use the tag ref="username" then you can access the element with this.refs.username so you can just setState onSubmit this.refs.username.value. - with ES6/2015 you are not always forced to bind the context, you can instead use the arrow function so the context of the function is automatically the one where the function is called!
Ex: onChange={ this.onChange.bind(this) }
becomes
onChange={ (ev) => this.onChange(ev) }ï»¿


## TO DO:
* `import` statements require extensions -- that's weird. shouldn't webpack be taking care of that?
* routes don't actually live in the routes file -- make it so
